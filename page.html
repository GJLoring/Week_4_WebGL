<html>

<head>
<title>Introduction to WebGL Lab</title>

<script src="vector3.js"></script>
<script src="matrix4.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexColor;

    uniform mat4 uWorldMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying vec3 vColor;

    void main(void){
        gl_Position =
            uProjectionMatrix *
            uViewMatrix *
            uWorldMatrix *
            vec4(aVertexPosition, 1.0);

        vColor = aVertexColor;
    }
</script>

<script id="vertex-shader" type="not-javascript">
    attribute vec3 coordinates;
    void main(){
        gl_Position = vec4(coordinates, 1.0);
        gl_PointSize = 10.0;
    }
</script>

<script id="fragment-shader" type="not-javascript">
    void main(){
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
</script>

<script type="text/javascript">

    // the main variable through which we will interact with webgl
    var gl;

    // we preallocate our matrix objects here and reuse them every frame
    var viewMatrix = new Matrix4();
    var projectionMatrix = new Matrix4();

    // the shader that will be used by each piece of geometry (they could each use their own shader but in this case it will be the same)
    var shaderProgram;

    var triangleGeometry = {
        // The core elements that we will need to render this object
        worldMatrix: null,               // the matrix that transforms this object from local space to world space
        shaderProgram: null,         // the shader program of "how" to render this object (vertex & fragment)
        positionBuffer: null,            // the buffer that holds all of the data associated with a vertex position
        colorBuffer: null,                 // the buffer that holds all of the data associated with a vertex color
        bufferItemCount: 3,            // how many vertices the buffer contains
    }

    // -------------------------------------------------------------------------
    function initializeAndStartRendering() {
        initGL();

        createShaders();

        /*
        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_Position);
        */
        // gl.useProgram(shaderProgram);

        createTriangleGeometry();
        //createLineGridGeometry();

        updateAndRender();
    }

    function createTriangleGeometry(){
        // create the position and color information for this object and send it to the GPU
        var newBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, newBuffer);
        var vertices = [
            0.0,  1.0,  0.0,      // (vertex 1: x, y, z)
            -1.0, -1.0,  0.0,     // (vertex 2: x, y, z)
            1.0, -1.0,  0.0,       // (vertex 3: x, y, z)
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        // allocate a matrix that we will reuse for this object
        triangleGeometry.worldMatrix = new Matrix4();

        // specify the shaders which carries the instructions for "how" to render
        triangleGeometry.shaderProgram = shaderProgram;
        triangleGeometry.positionBuffer = newBuffer;


        var newColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, newColorBuffer);
        var rgb = [
            0.0,  1.0,  0.0,      // (rgb)
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rgb), gl.STATIC_DRAW);
        triangleGeometry.colorBuffer = newColorBuffer;

        // Gabe note, this ( code from here to end of function ) feels like it should go in an event loop
        // Make sure the WebGL state knows this is the program we're working with
        gl.useProgram(shaderProgram);

        // Get a reference to the attribute "aVertexPosition"
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");

        // Turn on this attribute
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        // Do the same thing for our other piece of data (1d color)
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

        shaderProgram.worldMatrixUniform  = gl.getUniformLocation(shaderProgram, "uWorldMatrix");
        shaderProgram.viewMatrixUniform = gl.getUniformLocation(shaderProgram, "uViewMatrix");
        shaderProgram.projectionMatrixUniform = gl.getUniformLocation(shaderProgram, "uProjectionMatrix");

    }

    function renderTriangle() {
        // Send our matrices to the shader
        gl.uniformMatrix4fv(shaderProgram.worldMatrixUniform, false, triangleGeometry.worldMatrix.clone().transpose().elements);
        gl.uniformMatrix4fv(shaderProgram.viewMatrixUniform, false, viewMatrix.clone().transpose().elements);
        gl.uniformMatrix4fv(shaderProgram.projectionMatrixUniform, false, projectionMatrix.clone().transpose().elements);
    }


    function uniformMatrix4fv() {
    }

    // -------------------------------------------------------------------------
    // Get a valid link to the GL "context"
    function initGL(canvas) {
        var canvas = document.getElementById("webgl-canvas");

        try {
            gl = canvas.getContext("webgl");
        } catch (e) {}

        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }

        gl.enable(gl.DEPTH_TEST);
    }

    function createCompiledShader(shaderText, shaderType) {
        var shader = gl.createShader(shaderType);

        gl.shaderSource(shader, shaderText );
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            console.log(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    function createShaders() {
        // Get the objects representing individual shaders

        //var vertexShaderText = document.getElementById("vertex-shader").textContent;
        var vertexShaderText = document.getElementById("shader-vs").textContent;
        var vertexShader = createCompiledShader(vertexShaderText, gl.VERTEX_SHADER);
        var error_log = gl.getShaderInfoLog(vertexShader);
        console.log(error_log);
        var fragmentShaderText = document.getElementById("fragment-shader").textContent;
        var fragmentShader = createCompiledShader(fragmentShaderText, gl.FRAGMENT_SHADER);
        var error_log = gl.getShaderInfoLog(fragmentShader);
        console.log(error_log);


        //Todo #5 in the book, not sure if should be in sep function
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);

        // Tell gl it's ready to go, link it
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

    }


    // -------------------------------------------------------------------------
    function updateAndRender() {
        //requestAnimationFrame(render);

        gl.viewport(0, 0, 1024, 768);

        gl.clearColor(0.707, 0.707, 1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }

</script>

</head>


<body onload="initializeAndStartRendering();">
    <canvas id="webgl-canvas" style="border: none;" width="1024" height="768"></canvas>
</body>

</html>